# matlab笔记

## 1. size函数

size(X, 2)表示矩阵X的列数；size(X, 1)表示矩阵X的行数；



## 2. cell2mat将cell转换成矩阵

在 MATLAB 中，你可以使用 `**cell2mat**` 函数将 cell 数组转换为普通的矩阵。例子：

```matlab
matrix = cell2mat(cellArray);  % 使用 cell2mat 将 cell 转换为矩阵
```



## 3. 生成全都是同一个元素的矩阵，思路

```matalb
matrix = zeros(rows, columns); % 使用 zeros 函数创建一个全零矩阵
matrix(:) = 0.1; % 将所有元素设置为 0.1

% 生成随机数矩阵，但是每个元素都小于1：a行，

randomMatrix = rand(a, b);
minValue = 0;
maxValue = 0.5;
randomMatrix = minValue + (maxValue - minValue) * rand(rows, columns); 
```



## 4. 求矩阵的迹

> 1、高斯消元法：通过行变换将矩阵化为阶梯形矩阵或行最简形矩阵，然后计算对角线元素的和。这种方法适用于任何大小的矩阵，但对于非方阵可能无法直接求解。
>
> 2、伴随矩阵法：对于n阶方阵A，其伴随矩阵A^∗的迹等于A的迹，即tr(A) = tr(A^∗)。因此，可以通过计算伴随矩阵的迹来间接求解原矩阵的迹。
>
> 3、特征值法：对于一个n阶方阵A，如果其特征值λ满足|λ|=1，则A的迹等于所有特征值的和。这种方法需要计算特征值，可能存在一定的数值误差。
>
> 4、行列式法：对于n阶方阵A，其行列式的绝对值为A的迹，即|tr(A)| = |det(A)|。这种方法可以直接求解行列式，但对于非方阵可能无法直接求解。



## 5. 给未知变量分配空间

```matlab
x2(:,1)=zeros(n,1);*%**设定初始的**x**的值*
r2(:,1)=b**-**A*****x2(:,1);*%**初始的残量*

wk2=zeros(n,1);*%**这里只给* *wk* *分配* *n\*1* *的空间即可，因为我们可以每一次覆盖前面的*
ak2=zeros(n,1);*%**这里只给* *ak* *分配* *n\*1* *的空间即可，因为我们可以每一次覆盖前面的*
```



## 6. legend设置图像中的标签是否隐藏

（1）设置matlab图像的标签（选择性设置，就是想隐藏掉一些图像的标签）

```matlab
set1 = legend([plot_new, plot_arm],'牛顿法', 'Armijo法');
set(set1,'FontSize',15,'FontWeight','normal') % 设置大小
```

 

## 7. 矩阵A逆乘B:

​	A\B可近似看作A的逆乘B，即inv(A)*B；



## 8. 矩阵相关的函数

> 矩阵求逆：inv(A) 
>
> 求矩阵A的值：det(A)
>
> 求矩阵的秩：rank(A)
>
> 矩阵转置：A’
>
> 单位矩阵：eye(3)
>
> 求矩阵特征值跟特征向量[v, d] = eig(A) ,d是A的特征值，v是该特征值对应的特征向量（注意别反了）
>
> Repmat函数：把一个矩阵重复：例如repmat([1,2,3,4],2,3)会把其重复2行3列
>
>  
>
> 矩阵运算：矩阵相乘A * B
>
> 矩阵对应项相乘(除)：A .* B A ./ B
>
> 取A矩阵的第2行：A(2, :)
>
> 获取矩阵维数：mySize = size(A)，得到行、列



### 例子

* 特征根1=[-0.9992;0.0403], 特征根2=[0.0403; 0.9992]。	特征值lamda在对角线的位置上：为0.。8386和100.1614

> <img src="./笔记图片/matlabEig.png" alt="本地图片"  />

* 矩阵归一化

> ![本地图片](./笔记图片/matlab归一化.png)
>
> 



## 9. For循环：

> for 循环变量 = 初值 ： 步长 ： 终值
>
>    执行语句
>
> End
>
> If语句同理，以下是if语句示例：
>
> ```matlab
> if num_A ==3
> 	funcCR = funcCI/RI_3;
> elseif num_A == 4
> 	funcCR = funcCI/RI_4;
> elseif num_A == 5
> 	funcCR = funcCI/RI_5;
> else
> 	fprintf('输入有误！')
> end
> ```
>



## 10. matlab中的逻辑运算符

逻辑运算符：&（与）、|（或）、~（非）

||是见1出1，而&&是见0出0（||有真就真，&&有非就非），且左右几乎是分开的，判断条件相同的话要写两边都要

- "&&"运算符：先判断A的逻辑值，再判断B的值，最后才判断整个表达式的值。当A为假时，那么就之间认为这个表达上为假的，不再需要判断B的值。

- "||"运算符（同理）先判断A的逻辑值，下一步再判断B的值，最后才判断整个表达式的值。当A为假时，那么就之间认为这个表达上为假的，不再需要判断B的值。

==&&和||中：	A和B只能是标量，不能是矩阵。==



## 11. 